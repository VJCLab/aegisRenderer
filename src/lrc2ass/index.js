import lrcParser from "./parser.js";
/** @typedef {import("./parser.js").ParserResult} ParserResult */
/**
 * 숫자를 2자리 문자열로 패딩
 */
function pad(num) {
    return num.toString().padStart(2, '0');
}

/**
 * 초 단위의 시간을 ASS 형식의 시간으로 변환
 */
export function formatAssTime(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    const cs = Math.floor((seconds % 1) * 100);

    return `${h}:${pad(m)}:${pad(s)}.${pad(cs)}`;
}

// ASS 파일 헤더 생성
function genAssHeader(title = 'Converted LRC file') {
    return `[Script Info]
; Script generated by LRC to ASS converter
Title: ${title}
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,48,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Translation,Arial,40,&H0000FFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,2,8,10,10,50,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
}

// 진행 상황 이벤트 객체 생성 함수
const createProgressEvent = (phase, current, total, detail = null) => ({
    phase,
    current,
    total,
    progress: total > 0 ? (current / total) : 0,
    detail
});

/**
 * 텍스트에 CPS 기반 카라오케 \k 태그를 삽입
 * @param {string} text - 순수 텍스트
 * @param {number} durationInSeconds - 라인의 전체 지속 시간 (초 단위)
 * @returns {string} - \k 태그가 삽입된 텍스트
 */
function applyKaraokeTags(text, durationInSeconds) {
    const cleanText = text.replace(/\{.*?\}/g, ''); // 오버라이드 태그 제거
    const durationInCs = Math.round(durationInSeconds * 100);
    const numChars = cleanText.length || 1;
    const kValue = Math.floor(durationInCs / numChars) - 10;

    let karaText = '';
    for (const char of cleanText) {
        karaText += `{\\k${kValue}}${char}`;
    }

    return karaText;
}


/**
 * 각 자막 라인을 처리하는 함수
 * @param {String|ParserResult} lrcData 
 * @param {*} onProgress
 * @param {boolean} autoKaraoke - 노래방 태그 자동 추가 여부 (CPS에 의해 계산됨)
 * @returns { Promise<{assContent:string, lrcData:ParserResult}>}
 */
async function processLines(lrcData, onProgress, autoKaraoke = false) {
    let assContent = genAssHeader(lrcData.title);
    const { lines } = lrcData;
    const totalLines = lines.length;
    const batchSize = 20; // 한 번에 처리할 라인 수

    // 변환 시작 알림
    if (onProgress) {
        onProgress(createProgressEvent('converting', 0, totalLines, 'ASS 변환 시작'));
    }

    // 배치 처리를 위한 함수
    const processBatch = async (startIdx) => {
        const endIdx = Math.min(startIdx + batchSize, totalLines);
        let batchContent = '';
        for (let i = startIdx; i < endIdx; i++) {
            const currentLine = lines[i];
            const nextLine = lines[i + 1];

            const startTimeInSeconds = currentLine.time / 1000;
            const endTimeInSeconds = nextLine
                ? nextLine.time / 1000
                : startTimeInSeconds + 5;

            const startTime = formatAssTime(startTimeInSeconds);
            const endTime = formatAssTime(endTimeInSeconds);
            const duration = endTimeInSeconds - startTimeInSeconds;

            // 주 가사 텍스트 처리
            let mainText = currentLine.text;
            if (autoKaraoke && typeof mainText === 'string' && mainText.trim().length > 0) {
                mainText = applyKaraokeTags(mainText, duration);
            }

            batchContent += `Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${mainText}\n`;

            // 확장 가사 처리
            if (currentLine.extendedLyrics?.length > 0) {
                for (let translationText of currentLine.extendedLyrics) {
                    if (autoKaraoke && typeof translationText === 'string' && translationText.trim().length > 0) {
                        translationText = applyKaraokeTags(translationText, duration);
                    }
                    batchContent += `Dialogue: 0,${startTime},${endTime},Translation,,0,0,0,,${translationText}\n`;
                }
            }
        }

        return batchContent;
    };


    // 배치 단위로 처리
    for (let i = 0; i < totalLines; i += batchSize) {
        const batchContent = await processBatch(i);
        assContent += batchContent;

        // 진행 상황 알림
        if (onProgress) {
            const processed = Math.min(i + batchSize, totalLines);
            onProgress(createProgressEvent('converting', processed, totalLines,
                `라인 ${processed}/${totalLines} 변환 완료`));
        }

        // UI 블로킹 방지
        await new Promise(resolve => setTimeout(resolve, 0));
    }

    // 변환 완료 알림
    if (onProgress) {
        onProgress(createProgressEvent('completed', totalLines, totalLines, 'ASS 변환 완료'));
    }

    return { assContent, lrcData };
}

/**
 * LRC 파일을 ASS 형식으로 비동기 변환하는 함수
 * @param {String|ParserResult} lrcData
 * @param {*} onProgress
 * @param {boolean} removeBlankLine - 가사파일의 비어있는 라인 제거 여부
 * @param {boolean} autoKaraoke - 노래방 태그 자동 추가 여부 (CPS에 의해 계산됨)
 * @returns {Promise<{assContent:string, lrcData:ParserResult}|null>}
 */
async function lrc2ass(lrcData, onProgress = null, removeBlankLine = false, autoKaraoke = false) {
    if (!lrcData) return null;

    // LRC 파싱 처리
    if (typeof lrcData === "string") {
        if (onProgress) onProgress(createProgressEvent('parsing', 0, 100, 'LRC 파싱 시작'));

        try {
            lrcData = lrcParser(lrcData);
        } catch (error) {
            if (onProgress) onProgress({
                phase: 'error',
                error: error.message
            });
            return null;
        }

        if (onProgress) onProgress(createProgressEvent('parsing', 100, 100, 'LRC 파싱 완료'));
    }

    if (!lrcData.lines?.length) return null;

    // 라인 처리 시작
    return await processLines(lrcData, onProgress, autoKaraoke)
        .catch((error) => {
            if (onProgress) {
                onProgress({
                    phase: 'error',
                    error: error.message
                });
            }
            return null;
        })
}
export default lrc2ass;