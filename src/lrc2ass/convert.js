/** @typedef {import("./type.js").ParserResult} ParserResult */
/**
 * 숫자를 2자리 문자열로 패딩
 */
function pad(num) {
    return num.toString().padStart(2, '0');
}

/**
 * 초 단위의 시간을 ASS 형식의 시간으로 변환
 */
export function formatAssTime(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    const cs = Math.floor((seconds % 1) * 100);

    return `${h}:${pad(m)}:${pad(s)}.${pad(cs)}`;
}

// ASS 파일 헤더 생성
function genAssHeader(title = 'Converted LRC file') {
    return `[Script Info]
; Script generated by LRC to ASS converter
Title: ${title}
ScriptType: v4.00+
WrapStyle: 0
PlayResX: 1280
PlayResY: 720
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,48,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Translation,Arial,40,&H0000FFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,2,8,10,10,50,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
}

/**
 * 텍스트에 CPS 기반 카라오케 \k 태그를 삽입
 * @param {string} text - 순수 텍스트
 * @param {number} durationInSeconds - 라인의 전체 지속 시간 (초 단위)
 * @returns {string} - \k 태그가 삽입된 텍스트
 */
function applyKaraokeTags(text, durationInSeconds) {
    const cleanText = text.replace(/\{.*?\}/g, ''); // 오버라이드 태그 제거
    const durationInCs = Math.round(durationInSeconds * 100);
    const numChars = cleanText.length || 1;
    const kValue = Math.floor(durationInCs / numChars) - 10;

    let karaText = '';
    for (const char of cleanText) {
        karaText += `{\\k${kValue}}${char}`;
    }

    return karaText;
}

/**
 * 각 자막 라인을 처리하는 함수
 * @param {String|ParserResult} lrcData 
 * @param {*} onProgress
 * @param {boolean} autoKaraoke - 노래방 태그 자동 추가 여부 (CPS에 의해 계산됨)
 * @returns { Promise<{assContent:string, lrcData:ParserResult}>}
 */
async function processLines(lrcData, onProgress, autoKaraoke = false) {
    let assContent = genAssHeader(lrcData.title);
    const { lines } = lrcData;
    const totalLines = lines.length;
    const batchSize = 20; // 한 번에 처리할 라인 수
    const PERFORMANCE_AFTER = {
        start: performance.now(),
        end: null,
        diff: null
    }
    // 배치 처리를 위한 함수
    const processBatch = async (startIdx) => {
        const endIdx = Math.min(startIdx + batchSize, totalLines);
        let batchContent = '';
        for (let i = startIdx; i < endIdx; i++) {
            const currentLine = lines[i];
            const nextLine = lines[i + 1];

            const startTimeInSeconds = currentLine.time / 1000;
            const endTimeInSeconds = nextLine
                ? nextLine.time / 1000
                : startTimeInSeconds + 5;

            const startTime = formatAssTime(startTimeInSeconds);
            const endTime = formatAssTime(endTimeInSeconds);
            const duration = endTimeInSeconds - startTimeInSeconds;

            // 주 가사 텍스트 처리
            let mainText = currentLine.text;
            if (autoKaraoke && typeof mainText === 'string' && mainText.trim().length > 0) {
                mainText = applyKaraokeTags(mainText, duration);
            }

            batchContent += `Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${mainText}\n`;

            // 확장 가사 처리
            if (currentLine.extendedLyrics?.length > 0) {
                for (let translationText of currentLine.extendedLyrics) {
                    if (autoKaraoke && typeof translationText === 'string' && translationText.trim().length > 0) {
                        translationText = applyKaraokeTags(translationText, duration);
                    }
                    batchContent += `Dialogue: 0,${startTime},${endTime},Translation,,0,0,0,,${translationText}\n`;
                }
            }
        }

        return batchContent;
    };


    // 배치 단위로 처리
    for (let i = 0; i < totalLines; i += batchSize) {
        const batchContent = await processBatch(i);
        assContent += batchContent;

        // 진행 상황 알림
        if (onProgress) {
            const processed = Math.min(i + batchSize, totalLines);
            const ev = new ProgressEvent('progress', { lengthComputable: true, loaded: processed, total: totalLines });
            ev.phase = "converting";
            onProgress(ev);
        }

        // UI 블로킹 방지
        await new Promise(resolve => setTimeout(resolve, 0));
    }
    PERFORMANCE_AFTER.end = performance.now();
    PERFORMANCE_AFTER.diff = PERFORMANCE_AFTER.end - PERFORMANCE_AFTER.start;
    lrcData.PERFORMANCE_AFTER = PERFORMANCE_AFTER;
    return { assContent, lrcData, performance: PERFORMANCE_AFTER };
}

async function preProc(lyric = "", { removeBlankLine = false,
    eventTarget = null
} = {}) {
    try {
        // 워커 생성
        const worker = new Worker(new URL('./parse.js', import.meta.url), {
            type: 'module'
        });

        // 워커로부터의 응답을 기다리는 Promise 생성 및 즉시 await
        const result = await new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
                const { type, progress, result } = e.data;

                if (type === 'progress') {
                    const ev = new ProgressEvent('progress', progress);
                    ev.phase = "parsing";
                    eventTarget?.dispatchEvent(ev);

                } else if (type === 'done') {
                    resolve(result);
                }
            };

            worker.onerror = (e) => {
                const err = new Error(e.message);
                err.name = `LRCParserError`;
                reject(err);
            };

            // 워커에 파싱할 텍스트 전송
            worker.postMessage({
                rawText: lyric,
                removeBlankLine
            });
        }).catch(e => { throw e });

        // 작업 완료 후 워커 종료
        worker.terminate();

        return result;
    } catch (error) {
        throw error;
    }
}
/**
* LRC 파일을 ASS 형식으로 비동기 변환하는 함수
* @this {EventTarget}
* @param {String|ParserResult} lrcData
* @param {object} options
* @param {boolean} options.removeBlankLine - 가사파일의 비어있는 라인 제거 여부
* @param {boolean} options.autoKaraoke - 노래방 태그 자동 추가 여부
* @returns {Promise<{assContent:string, lrcData:ParserResult}|null>}
*/
async function convert(lrcData, {
    removeBlankLine = false, autoKaraoke = false
} = {}) {
    if (!lrcData) return null;
    if (typeof lrcData === "string") {
        await preProc(lrcData, { removeBlankLine, eventTarget: this }).then(result => lrcData = result);
    }
    if (!lrcData.lines?.length) return null;
    // console.log(lrcData);
    let onProgress = (e) => console.log(e);

    // 라인 처리 시작
    return await processLines(lrcData, e => this.dispatchEvent(e), autoKaraoke)
        .catch((error) => {
            if (onProgress) {
                onProgress({
                    phase: 'error',
                    error: error.message
                });
            }
            return null;
        })
}
export default convert;